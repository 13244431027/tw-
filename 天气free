(function(Scratch) {
  'use strict';
  
  class WeatherExtension {
    constructor() {
      this.currentWeatherData = null;
      this.lastFetchTime = 0;
      this.cacheDuration = 600000;
      this.favoriteLocations = [];
      this.weatherHistory = [];
      this.maxHistorySize = 50;
      this.userPreferences = {
        defaultUnit: '‚ÑÉ',
        defaultWindUnit: 'km/h',
        language: 'zh'
      };
    }
    
    getInfo() {
      return {
        id: 'weatherextension',
        name: 'üå§Ô∏è È´òÁ∫ßÂ§©Ê∞îÊâ©Â±ï',
        color1: '#4A90E2',
        color2: '#357ABD',
        color3: '#2C6CB3',
        blocks: [
          {
            opcode: 'getWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂ§©Ê∞î',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'getTemperature',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÊ∏©Â∫¶ (Âçï‰Ωç: [UNIT])',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'UNIT_MENU'
              }
            }
          },
          {
            opcode: 'getDetailedWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑËØ¶ÁªÜÂ§©Ê∞î (Ê†ºÂºè: [FORMAT])',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              FORMAT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'FORMAT_MENU'
              }
            }
          },
          "---",
          {
            opcode: 'getWeatherForecast',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑ [PERIOD] È¢ÑÊä•',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              PERIOD: {
                type: Scratch.ArgumentType.STRING,
                menu: 'PERIOD_MENU'
              }
            }
          },
          {
            opcode: 'getHourlyWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑ [HOUR] Â∞èÊó∂È¢ÑÊä•',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              HOUR: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 6
              }
            }
          },
          {
            opcode: 'getWeeklySummary',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂë®Â§©Ê∞îÊëòË¶Å',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'getWeatherAlerts',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂ§©Ê∞îË≠¶Êä•',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'getAirQuality',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÁ©∫Ê∞îË¥®Èáè',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'getPollenInfo',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑËä±Á≤â‰ø°ÊÅØ',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'getAstronomyData',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑ [ASTRONOMY_TYPE] Êó∂Èó¥',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              ASTRONOMY_TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ASTRONOMY_MENU'
              }
            }
          },
          {
            opcode: 'getMoonPhaseInfo',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑ÂèñÊúàÁõ∏‰ø°ÊÅØ [DATE]',
            arguments: {
              DATE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '‰ªäÂ§©'
              }
            }
          },
          {
            opcode: 'getSeasonInfo',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂ≠£ËäÇ‰ø°ÊÅØ',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'compareLocations',
            blockType: Scratch.BlockType.REPORTER,
            text: 'ÊØîËæÉ [LOCATION1] Âíå [LOCATION2] ÁöÑ [COMPARE_TYPE]',
            arguments: {
              LOCATION1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              LOCATION2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '‰∏äÊµ∑'
              },
              COMPARE_TYPE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COMPARE_MENU'
              }
            }
          },
          {
            opcode: 'getWeatherTrend',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂ§©Ê∞îË∂ãÂäø',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'calculateComfortIndex',
            blockType: Scratch.BlockType.REPORTER,
            text: 'ËÆ°ÁÆó [LOCATION] ÁöÑËàíÈÄÇÂ∫¶ÊåáÊï∞',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'getTravelWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [DESTINATION] ÁöÑÊóÖË°åÂ§©Ê∞îÂª∫ËÆÆ (‰ªé [ORIGIN])',
            arguments: {
              DESTINATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '‰∏â‰∫ö'
              },
              ORIGIN: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'getActivityRecommendation',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑ [ACTIVITY] Ê¥ªÂä®Âª∫ËÆÆ',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              ACTIVITY: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ACTIVITY_MENU'
              }
            }
          },
          {
            opcode: 'getClothingAdvice',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÁ©øË°£Âª∫ËÆÆ',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'getHistoricalWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂéÜÂè≤Â§©Ê∞î [DAYS] Â§©Ââç',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              },
              DAYS: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              }
            }
          },
          {
            opcode: 'getWeatherStatistics',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÂ§©Ê∞îÁªüËÆ°',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          {
            opcode: 'getExtremeWeather',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑Âèñ [LOCATION] ÁöÑÊûÅÁ´ØÂ§©Ê∞îËÆ∞ÂΩï',
            arguments: {
              LOCATION: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: 'Âåó‰∫¨'
              }
            }
          },
          "---",
          {
            opcode: 'setUserPreference',
            blockType: Scratch.BlockType.COMMAND,
            text: 'ËÆæÁΩÆÂÅèÂ•Ω [PREFERENCE] ‰∏∫ [VALUE]',
            arguments: {
              PREFERENCE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'PREFERENCE_MENU'
              },
              VALUE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VALUE_MENU'
              }
            }
          },
          {
            opcode: 'getSystemStatus',
            blockType: Scratch.BlockType.REPORTER,
            text: 'Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅ'
          }
        ],
        menus: {
          UNIT_MENU: {
            items: ['‚ÑÉ', '‚Ñâ']
          },
          FORMAT_MENU: {
            items: ['ÁÆÄÊ¥Å', 'ËØ¶ÁªÜ', 'JSON', 'Ë°®Ê†º']
          },
          PERIOD_MENU: {
            items: ['‰ªäÂ§©', 'ÊòéÂ§©', '3Â§©', '‰∏ÄÂë®']
          },
          ASTRONOMY_MENU: {
            items: ['Êó•Âá∫', 'Êó•ËêΩ', 'ÊúàÂá∫', 'ÊúàËêΩ', 'Êó•ÁÖßÊó∂Èïø']
          },
          COMPARE_MENU: {
            items: ['Ê∏©Â∫¶', 'ÊπøÂ∫¶', 'È£éÈÄü', 'Â§©Ê∞îÁä∂ÂÜµ', 'ÁªºÂêà']
          },
          ACTIVITY_MENU: {
            items: ['Êà∑Â§ñËøêÂä®', 'ÊóÖÊ∏∏ËßÇÂÖâ', 'ÊëÑÂΩ±', 'ÈíìÈ±º', 'ÈáéÈ§ê', 'ÊªëÈõ™']
          },
          PREFERENCE_MENU: {
            items: ['Ê∏©Â∫¶Âçï‰Ωç', 'È£éÈÄüÂçï‰Ωç', 'ËØ≠Ë®Ä']
          },
          VALUE_MENU: {
            items: ['‚ÑÉ', '‚Ñâ', 'km/h', 'm/s', 'mph', '‰∏≠Êñá', 'Ëã±Êñá']
          }
        }
      };
    }

    async fetchWeatherData(location) {
      const now = Date.now();
      
      // Ê£ÄÊü•ÁºìÂ≠ò
      if (this.currentWeatherData && 
          this.currentWeatherData.location === location && 
          (now - this.lastFetchTime) < this.cacheDuration) {
        return this.currentWeatherData;
      }
      
      try {
        const encodedLocation = encodeURIComponent(location);
        const response = await fetch(`https://wttr.in/${encodedLocation}?format=j1&lang=${this.userPreferences.language === 'Ëã±Êñá' ? 'en' : 'zh'}`);
        
        if (!response.ok) {
          throw new Error(`HTTPÈîôËØØ! Áä∂ÊÄÅÁ†Å: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Ê∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï
        this.addToHistory(location, data);
        
        this.currentWeatherData = {
          location: location,
          data: data,
          timestamp: now
        };
        
        this.lastFetchTime = now;
        return this.currentWeatherData;
        
      } catch (error) {
        console.error('Ëé∑ÂèñÂ§©Ê∞îÊï∞ÊçÆÂ§±Ë¥•:', error);
        throw new Error(`Êó†Ê≥ïËé∑Âèñ ${location} ÁöÑÂ§©Ê∞îÊï∞ÊçÆ`);
      }
    }

    addToHistory(location, data) {
      const historyItem = {
        location: location,
        data: JSON.parse(JSON.stringify(data)),
        timestamp: Date.now()
      };
      
      this.weatherHistory.unshift(historyItem);
      
      if (this.weatherHistory.length > this.maxHistorySize) {
        this.weatherHistory = this.weatherHistory.slice(0, this.maxHistorySize);
      }
    }

    // Âü∫Á°ÄÂ§©Ê∞îÂäüËÉΩ
    async getWeather(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const emoji = await this.getWeatherEmoji({LOCATION: args.LOCATION});
        
        return `${emoji} ${args.LOCATION}: ${current.weatherDesc[0].value} ${current.temp_C}‚ÑÉ`;
      } catch (error) {
        return error.message;
      }
    }

    async getTemperature(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const unit = args.UNIT || this.userPreferences.defaultUnit;
        
        return unit === '‚Ñâ' ? current.temp_F : current.temp_C;
      } catch (error) {
        return error.message;
      }
    }

    async getDetailedWeather(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const astronomy = weatherData.data.weather[0].astronomy[0];
        const emoji = await this.getWeatherEmoji({LOCATION: args.LOCATION});
        
        switch (args.FORMAT) {
          case 'ËØ¶ÁªÜ':
            return `${emoji} ${args.LOCATION} ËØ¶ÁªÜÂ§©Ê∞îÊä•ÂëäÔºö
üå°Ô∏è Ê∏©Â∫¶: ${current.temp_C}‚ÑÉ (‰ΩìÊÑü ${current.FeelsLikeC}‚ÑÉ)
‚òÅÔ∏è Â§©Ê∞î: ${current.weatherDesc[0].value}
üíß ÊπøÂ∫¶: ${current.humidity}%
üí® È£éÈÄü: ${current.windspeedKmph} km/h
üß≠ È£éÂêë: ${current.winddir16Point}
üìä Ê∞îÂéã: ${current.pressure} hPa
üëÅÔ∏è ËÉΩËßÅÂ∫¶: ${current.visibility} km
‚òÄÔ∏è Á¥´Â§ñÁ∫ø: ${current.uvIndex || 'Êú™Áü•'}
üåÖ Êó•Âá∫: ${astronomy.sunrise} üåá Êó•ËêΩ: ${astronomy.sunset}`;
            
          case 'JSON':
            return JSON.stringify({
              location: args.LOCATION,
              temperature: current.temp_C,
              feelsLike: current.FeelsLikeC,
              condition: current.weatherDesc[0].value,
              humidity: current.humidity,
              windSpeed: current.windspeedKmph,
              windDirection: current.winddir16Point,
              pressure: current.pressure,
              visibility: current.visibility,
              uvIndex: current.uvIndex,
              sunrise: astronomy.sunrise,
              sunset: astronomy.sunset
            }, null, 2);
            
          case 'Ë°®Ê†º':
            return `üìç ${args.LOCATION}
üå°Ô∏è  ${current.temp_C}‚ÑÉ | üíß ${current.humidity}%
üí®  ${current.windspeedKmph}km/h | üìä ${current.pressure}hPa
üåÖ ${astronomy.sunrise} | üåá ${astronomy.sunset}`;
            
          default: // ÁÆÄÊ¥Å
            return `${emoji} ${args.LOCATION}: ${current.weatherDesc[0].value} ${current.temp_C}‚ÑÉ`;
        }
      } catch (error) {
        return error.message;
      }
    }

    // Â§©Ê∞îÈ¢ÑÊä•ÂäüËÉΩ
    async getWeatherForecast(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const weather = weatherData.data.weather;
        
        let forecastText = `${args.LOCATION} Â§©Ê∞îÈ¢ÑÊä•:\n`;
        
        switch (args.PERIOD) {
          case 'ÊòéÂ§©':
            const tomorrow = weather[1];
            forecastText += `ÊòéÂ§©: ${tomorrow.hourly[4].weatherDesc[0].value} ${tomorrow.mintempC}~${tomorrow.maxtempC}‚ÑÉ`;
            break;
            
          case '3Â§©':
            for (let i = 0; i < 3; i++) {
              const day = weather[i];
              const dayName = i === 0 ? '‰ªäÂ§©' : i === 1 ? 'ÊòéÂ§©' : 'ÂêéÂ§©';
              forecastText += `${dayName}: ${day.hourly[4].weatherDesc[0].value} ${day.mintempC}~${day.maxtempC}‚ÑÉ\n`;
            }
            break;
            
          case '‰∏ÄÂë®':
            for (let i = 0; i < Math.min(7, weather.length); i++) {
              const day = weather[i];
              const dayName = i === 0 ? '‰ªäÂ§©' : i === 1 ? 'ÊòéÂ§©' : `Á¨¨${i+1}Â§©`;
              forecastText += `${dayName}: ${day.hourly[4].weatherDesc[0].value} ${day.mintempC}~${day.maxtempC}‚ÑÉ\n`;
            }
            break;
            
          default: // ‰ªäÂ§©
            const today = weather[0];
            forecastText += `‰ªäÂ§©: ${today.hourly[4].weatherDesc[0].value} ${today.mintempC}~${today.maxtempC}‚ÑÉ`;
        }
        
        return forecastText;
      } catch (error) {
        return error.message;
      }
    }

    async getHourlyWeather(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const hourly = weatherData.data.weather[0].hourly;
        
        const hourIndex = Math.min(Math.max(0, Math.floor(args.HOUR / 3)), 7);
        const forecast = hourly[hourIndex];
        
        return `${args.HOUR}Â∞èÊó∂Âêé: ${forecast.weatherDesc[0].value} ${forecast.tempC}‚ÑÉ (ÈôçÊ∞¥Ê¶ÇÁéá: ${forecast.chanceofrain}%)`;
      } catch (error) {
        return error.message;
      }
    }

    async getWeeklySummary(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const weather = weatherData.data.weather;
        
        let summary = `${args.LOCATION} Êú¨Âë®Â§©Ê∞îÊëòË¶Å:\n`;
        let totalTemp = 0;
        let rainyDays = 0;
        
        for (let i = 0; i < Math.min(7, weather.length); i++) {
          const day = weather[i];
          totalTemp += (parseInt(day.maxtempC) + parseInt(day.mintempC)) / 2;
          
          if (parseInt(day.hourly[4].chanceofrain) > 50) {
            rainyDays++;
          }
        }
        
        const avgTemp = (totalTemp / Math.min(7, weather.length)).toFixed(1);
        summary += `Âπ≥ÂùáÊ∏©Â∫¶: ${avgTemp}‚ÑÉ\n`;
        summary += `È¢ÑËÆ°Èõ®Â§©: ${rainyDays}Â§©\n`;
        summary += `‰∏ªË¶ÅÂ§©Ê∞î: ${weather[0].hourly[4].weatherDesc[0].value}`;
        
        return summary;
      } catch (error) {
        return error.message;
      }
    }

    // È´òÁ∫ßÂ§©Ê∞î‰ø°ÊÅØ
    async getWeatherAlerts(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        const temp = parseInt(current.temp_C);
        const windSpeed = parseInt(current.windspeedKmph);
        const precip = parseFloat(current.precipMM);
        const visibility = parseInt(current.visibility);
        
        let alerts = [];
        
        if (temp >= 35) alerts.push('üî• È´òÊ∏©È¢ÑË≠¶');
        if (temp <= -10) alerts.push('‚ùÑÔ∏è ‰ΩéÊ∏©È¢ÑË≠¶');
        if (windSpeed >= 50) alerts.push('üí® Â§ßÈ£éÈ¢ÑË≠¶');
        if (precip >= 50) alerts.push('üåßÔ∏è Êö¥Èõ®È¢ÑË≠¶');
        if (visibility <= 1) alerts.push('üå´Ô∏è Â§ßÈõæÈ¢ÑË≠¶');
        if (parseInt(current.uvIndex) >= 8) alerts.push('‚òÄÔ∏è Âº∫Á¥´Â§ñÁ∫øÈ¢ÑË≠¶');
        
        return alerts.length > 0 ? alerts.join(' | ') : '‚úÖ Êó†Â§©Ê∞îË≠¶Êä•';
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÂ§©Ê∞îË≠¶Êä•';
      }
    }

    async getAirQuality(args) {
      try {
        // Ê®°ÊãüÁ©∫Ê∞îË¥®ÈáèÊï∞ÊçÆÔºàÂÆûÈôÖÈúÄË¶ÅÊé•ÂÖ•Á©∫Ê∞îË¥®ÈáèAPIÔºâ
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        // Âü∫‰∫éÂ§©Ê∞îÊù°‰ª∂‰º∞ÁÆóÁ©∫Ê∞îË¥®Èáè
        const humidity = parseInt(current.humidity);
        const windSpeed = parseInt(current.windspeedKmph);
        const pressure = parseInt(current.pressure);
        
        let aqi = 50; // Âü∫Á°ÄÂÄº
        
        // ÁÆÄÂçïÁöÑÁ©∫Ê∞îË¥®Èáè‰º∞ÁÆóÈÄªËæë
        if (windSpeed > 20) aqi -= 10; // È£éÂ§ßÁ©∫Ê∞îË¥®ÈáèÂ•Ω
        if (humidity > 80) aqi += 10; // ÊπøÂ∫¶ËøáÈ´òÁ©∫Ê∞îË¥®ÈáèÂ∑Æ
        if (pressure < 1000) aqi += 5; // ‰ΩéÊ∞îÂéãÁ©∫Ê∞îË¥®ÈáèÂ∑Æ
        
        aqi = Math.max(0, Math.min(100, aqi));
        
        let level, emoji;
        if (aqi <= 25) { level = '‰ºò'; emoji = 'üíö'; }
        else if (aqi <= 50) { level = 'ËâØ'; emoji = 'üíõ'; }
        else if (aqi <= 75) { level = '‰∏≠'; emoji = 'üß°'; }
        else { level = 'Â∑Æ'; emoji = '‚ù§Ô∏è'; }
        
        return `${emoji} Á©∫Ê∞îË¥®Èáè: ${level} (AQI: ${aqi})`;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÁ©∫Ê∞îË¥®Èáè';
      }
    }

    async getPollenInfo(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        const temp = parseInt(current.temp_C);
        const humidity = parseInt(current.humidity);
        const windSpeed = parseInt(current.windspeedKmph);
        
        let pollenLevel = '‰Ωé';
        let emoji = '‚úÖ';
        
        // ÁÆÄÂçïÁöÑËä±Á≤âÊåáÊï∞‰º∞ÁÆó
        if (temp >= 15 && temp <= 25 && humidity >= 40 && humidity <= 70 && windSpeed < 20) {
          pollenLevel = 'È´ò';
          emoji = '‚ö†Ô∏è';
        } else if (temp >= 10 && temp <= 28 && humidity >= 30 && humidity <= 80) {
          pollenLevel = '‰∏≠';
          emoji = '‚ÑπÔ∏è';
        }
        
        return `${emoji} Ëä±Á≤âÊåáÊï∞: ${pollenLevel}`;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñËä±Á≤â‰ø°ÊÅØ';
      }
    }

    // Â§©Êñá‰ø°ÊÅØ
    async getAstronomyData(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const astronomy = weatherData.data.weather[0].astronomy[0];
        
        switch (args.ASTRONOMY_TYPE) {
          case 'Êó•Âá∫':
            return `üåÖ Êó•Âá∫Êó∂Èó¥: ${astronomy.sunrise}`;
          case 'Êó•ËêΩ':
            return `üåá Êó•ËêΩÊó∂Èó¥: ${astronomy.sunset}`;
          case 'ÊúàÂá∫':
            return `üåô ÊúàÂá∫Êó∂Èó¥: ${astronomy.moonrise || 'Êú™Áü•'}`;
          case 'ÊúàËêΩ':
            return `üåô ÊúàËêΩÊó∂Èó¥: ${astronomy.moonset || 'Êú™Áü•'}`;
          case 'Êó•ÁÖßÊó∂Èïø':
            // ËÆ°ÁÆóÊó•ÁÖßÊó∂ÈïøÔºàÁÆÄÂåñËÆ°ÁÆóÔºâ
            const sunrise = astronomy.sunrise.split(':');
            const sunset = astronomy.sunset.split(':');
            const sunHours = parseInt(sunset[0]) - parseInt(sunrise[0]);
            const sunMinutes = parseInt(sunset[1]) - parseInt(sunrise[1]);
            return `‚òÄÔ∏è Êó•ÁÖßÊó∂Èïø: ${sunHours}Â∞èÊó∂${sunMinutes}ÂàÜÈíü`;
          default:
            return 'Êú™Áü•Â§©ÊñáÊï∞ÊçÆ';
        }
      } catch (error) {
        return error.message;
      }
    }

    async getMoonPhaseInfo(args) {
      try {
        let dateParam = '';
        if (args.DATE !== '‰ªäÂ§©') {
          dateParam = `@${args.DATE}`;
        }
        
        const response = await fetch(`https://wttr.in/Moon${dateParam}?format=%m&lang=zh`);
        const moonPhase = await response.text();
        
        const phaseMap = {
          'üåë': 'Êñ∞Êúà',
          'üåí': 'ËõæÁúâÊúà',
          'üåì': '‰∏äÂº¶Êúà',
          'üåî': 'ÁõàÂá∏Êúà',
          'üåï': 'Êª°Êúà',
          'üåñ': '‰∫èÂá∏Êúà',
          'üåó': '‰∏ãÂº¶Êúà',
          'üåò': 'ÊÆãÊúà'
        };
        
        const phaseEmoji = moonPhase.trim();
        const phaseName = phaseMap[phaseEmoji] || 'Êú™Áü•ÊúàÁõ∏';
        
        return `${phaseEmoji} ${phaseName}`;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÊúàÁõ∏‰ø°ÊÅØ';
      }
    }

    async getSeasonInfo(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const temp = parseInt(current.temp_C);
        
        let season, emoji;
        if (temp >= 25) {
          season = 'Â§èÂ≠£';
          emoji = '‚òÄÔ∏è';
        } else if (temp >= 15) {
          season = 'Êò•Â≠£';
          emoji = 'üåº';
        } else if (temp >= 5) {
          season = 'ÁßãÂ≠£';
          emoji = 'üçÇ';
        } else {
          season = 'ÂÜ¨Â≠£';
          emoji = '‚õÑ';
        }
        
        return `${emoji} ÂΩìÂâçÂ≠£ËäÇÁâπÂæÅ: ${season}`;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÂ≠£ËäÇ‰ø°ÊÅØ';
      }
    }

    // ÊØîËæÉÂíåÂàÜÊûêÂäüËÉΩ
    async compareLocations(args) {
      try {
        const [weather1, weather2] = await Promise.all([
          this.fetchWeatherData(args.LOCATION1),
          this.fetchWeatherData(args.LOCATION2)
        ]);
        
        const current1 = weather1.data.current_condition[0];
        const current2 = weather2.data.current_condition[0];
        
        switch (args.COMPARE_TYPE) {
          case 'Ê∏©Â∫¶':
            const temp1 = parseInt(current1.temp_C);
            const temp2 = parseInt(current2.temp_C);
            const diff = temp1 - temp2;
            return diff > 0 ? 
              `${args.LOCATION1} ÊØî ${args.LOCATION2} È´ò ${Math.abs(diff)}‚ÑÉ` :
              diff < 0 ? 
              `${args.LOCATION1} ÊØî ${args.LOCATION2} ‰Ωé ${Math.abs(diff)}‚ÑÉ` :
              `‰∏§Âú∞Ê∏©Â∫¶Áõ∏Âêå`;
              
          case 'ÊπøÂ∫¶':
            const hum1 = parseInt(current1.humidity);
            const hum2 = parseInt(current2.humidity);
            return `ÊπøÂ∫¶ÂØπÊØî: ${args.LOCATION1} ${hum1}% vs ${args.LOCATION2} ${hum2}%`;
            
          case 'È£éÈÄü':
            const wind1 = parseInt(current1.windspeedKmph);
            const wind2 = parseInt(current2.windspeedKmph);
            return `È£éÈÄüÂØπÊØî: ${args.LOCATION1} ${wind1}km/h vs ${args.LOCATION2} ${wind2}km/h`;
            
          case 'Â§©Ê∞îÁä∂ÂÜµ':
            return `Â§©Ê∞îÂØπÊØî: ${args.LOCATION1} ${current1.weatherDesc[0].value} vs ${args.LOCATION2} ${current2.weatherDesc[0].value}`;
            
          case 'ÁªºÂêà':
            return `ÁªºÂêàÂØπÊØî:
${args.LOCATION1}: ${current1.temp_C}‚ÑÉ ${current1.weatherDesc[0].value}
${args.LOCATION2}: ${current2.temp_C}‚ÑÉ ${current2.weatherDesc[0].value}`;
        }
      } catch (error) {
        return error.message;
      }
    }

    async getWeatherTrend(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const weather = weatherData.data.weather;
        
        let trend = `${args.LOCATION} Â§©Ê∞îË∂ãÂäø:\n`;
        
        for (let i = 0; i < Math.min(3, weather.length); i++) {
          const day = weather[i];
          const dayName = i === 0 ? '‰ªäÂ§©' : i === 1 ? 'ÊòéÂ§©' : 'ÂêéÂ§©';
          const tempTrend = i > 0 ? 
            `(${parseInt(day.maxtempC) - parseInt(weather[i-1].maxtempC) > 0 ? '‚Üë' : '‚Üì'})` : '';
          
          trend += `${dayName}: ${day.maxtempC}‚ÑÉ${tempTrend} ${day.hourly[4].weatherDesc[0].value}\n`;
        }
        
        return trend;
      } catch (error) {
        return error.message;
      }
    }

    async calculateComfortIndex(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        const temp = parseInt(current.temp_C);
        const humidity = parseInt(current.humidity);
        const windSpeed = parseInt(current.windspeedKmph);
        
        // ÁÆÄÂåñÁöÑËàíÈÄÇÂ∫¶ËÆ°ÁÆó
        let comfortScore = 100;
        
        // Ê∏©Â∫¶ÂΩ±Âìç (ÊúÄÈÄÇÊ∏©Â∫¶ 20-25‚ÑÉ)
        if (temp < 10 || temp > 30) comfortScore -= 30;
        else if (temp < 15 || temp > 25) comfortScore -= 15;
        
        // ÊπøÂ∫¶ÂΩ±Âìç (ÊúÄÈÄÇÊπøÂ∫¶ 40-60%)
        if (humidity < 30 || humidity > 80) comfortScore -= 20;
        else if (humidity < 40 || humidity > 60) comfortScore -= 10;
        
        // È£éÈÄüÂΩ±Âìç
        if (windSpeed > 30) comfortScore -= 15;
        else if (windSpeed > 20) comfortScore -= 5;
        
        comfortScore = Math.max(0, Math.min(100, comfortScore));
        
        let level, emoji;
        if (comfortScore >= 80) { level = 'ÈùûÂ∏∏ËàíÈÄÇ'; emoji = 'üòä'; }
        else if (comfortScore >= 60) { level = 'ËàíÈÄÇ'; emoji = 'üôÇ'; }
        else if (comfortScore >= 40) { level = '‰∏ÄËà¨'; emoji = 'üòê'; }
        else { level = '‰∏çËàíÈÄÇ'; emoji = 'üòû'; }
        
        return `${emoji} ËàíÈÄÇÂ∫¶: ${level} (${comfortScore}/100)`;
      } catch (error) {
        return 'Êó†Ê≥ïËÆ°ÁÆóËàíÈÄÇÂ∫¶';
      }
    }

    // ÂÆûÁî®Âª∫ËÆÆÂäüËÉΩ
    async getTravelWeather(args) {
      try {
        const [originWeather, destWeather] = await Promise.all([
          this.fetchWeatherData(args.ORIGIN),
          this.fetchWeatherData(args.DESTINATION)
        ]);
        
        const originTemp = parseInt(originWeather.data.current_condition[0].temp_C);
        const destTemp = parseInt(destWeather.data.current_condition[0].temp_C);
        const destCondition = destWeather.data.current_condition[0].weatherDesc[0].value;
        
        const tempDiff = destTemp - originTemp;
        
        let advice = `‰ªé ${args.ORIGIN} Âà∞ ${args.DESTINATION} ÁöÑÊóÖË°åÂª∫ËÆÆ:\n`;
        advice += `ÁõÆÁöÑÂú∞Â§©Ê∞î: ${destCondition} ${destTemp}‚ÑÉ\n`;
        
        if (Math.abs(tempDiff) > 10) {
          advice += `üí° Ê∏©Â∫¶Â∑ÆÂºÇËæÉÂ§ßÔºåËØ∑ÂáÜÂ§áÂêàÈÄÇÁöÑË°£Áâ©\n`;
        }
        
        if (destCondition.includes('Èõ®')) {
          advice += `üåÇ Âª∫ËÆÆÊê∫Â∏¶Èõ®ÂÖ∑\n`;
        }
        
        if (destTemp > 30) {
          advice += `üß¥ Ê≥®ÊÑèÈò≤ÊôíÂíåË°•Ê∞¥\n`;
        } else if (destTemp < 5) {
          advice += `üß£ Ê≥®ÊÑè‰øùÊöñ\n`;
        }
        
        return advice;
      } catch (error) {
        return error.message;
      }
    }

    async getActivityRecommendation(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        const temp = parseInt(current.temp_C);
        const condition = current.weatherDesc[0].value;
        const windSpeed = parseInt(current.windspeedKmph);
        
        let recommendation = `${args.LOCATION} ÁöÑ${args.ACTIVITY}Âª∫ËÆÆ: `;
        
        switch (args.ACTIVITY) {
          case 'Êà∑Â§ñËøêÂä®':
            if (condition.includes('Êô¥') && temp >= 15 && temp <= 28 && windSpeed < 20) {
              recommendation += '‚úÖ ÈùûÂ∏∏ÈÄÇÂêàÊà∑Â§ñËøêÂä®';
            } else if (condition.includes('Èõ®')) {
              recommendation += '‚ùå ‰∏çÈÄÇÂêàÊà∑Â§ñËøêÂä®';
            } else {
              recommendation += '‚ö†Ô∏è Êù°‰ª∂‰∏ÄËà¨ÔºåËØ∑Ê≥®ÊÑèÂÆâÂÖ®';
            }
            break;
            
          case 'ÊóÖÊ∏∏ËßÇÂÖâ':
            if (!condition.includes('Èõ®') && temp >= 10 && temp <= 30) {
              recommendation += '‚úÖ ÈÄÇÂêàÊóÖÊ∏∏ËßÇÂÖâ';
            } else {
              recommendation += '‚ö†Ô∏è ÊóÖÊ∏∏Êù°‰ª∂‰∏ÄËà¨';
            }
            break;
            
          case 'ÊëÑÂΩ±':
            if (condition.includes('Êô¥') || condition.includes('‰∫ë')) {
              recommendation += '‚úÖ ÂÖâÁ∫øÊù°‰ª∂ËâØÂ•ΩÔºåÈÄÇÂêàÊëÑÂΩ±';
            } else {
              recommendation += '‚ö†Ô∏è ÊëÑÂΩ±Êù°‰ª∂‰∏ÄËà¨';
            }
            break;
            
          case 'ÈíìÈ±º':
            if (temp >= 15 && windSpeed < 15) {
              recommendation += '‚úÖ ÈÄÇÂêàÈíìÈ±º';
            } else {
              recommendation += '‚ö†Ô∏è ÈíìÈ±ºÊù°‰ª∂‰∏ÄËà¨';
            }
            break;
            
          case 'ÈáéÈ§ê':
            if (condition.includes('Êô¥') && temp >= 18 && temp <= 28 && windSpeed < 15) {
              recommendation += '‚úÖ ÈùûÂ∏∏ÈÄÇÂêàÈáéÈ§ê';
            } else {
              recommendation += '‚ö†Ô∏è ÈáéÈ§êÊù°‰ª∂‰∏ÄËà¨';
            }
            break;
            
          case 'ÊªëÈõ™':
            if (temp < 0 && condition.includes('Èõ™')) {
              recommendation += '‚úÖ ÈùûÂ∏∏ÈÄÇÂêàÊªëÈõ™';
            } else if (temp < 5) {
              recommendation += '‚ö†Ô∏è ÊªëÈõ™Êù°‰ª∂‰∏ÄËà¨';
            } else {
              recommendation += '‚ùå ‰∏çÈÄÇÂêàÊªëÈõ™';
            }
            break;
        }
        
        return recommendation;
      } catch (error) {
        return error.message;
      }
    }

    async getClothingAdvice(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        
        const temp = parseInt(current.temp_C);
        const condition = current.weatherDesc[0].value;
        const windSpeed = parseInt(current.windspeedKmph);
        
        let clothing = `${args.LOCATION} ÁöÑÁ©øË°£Âª∫ËÆÆ:\n`;
        
        if (temp >= 28) {
          clothing += 'üëï Áü≠Ë¢ñ„ÄÅÁü≠Ë£§\n';
          clothing += 'üß¥ Ê≥®ÊÑèÈò≤Êôí\n';
        } else if (temp >= 20) {
          clothing += 'üëî ÈïøË¢ñTÊÅ§„ÄÅËñÑÂ§ñÂ•ó\n';
        } else if (temp >= 10) {
          clothing += 'üß• ÊØõË°£„ÄÅÂ§πÂÖã\n';
        } else if (temp >= 0) {
          clothing += 'üß£ ÂéöÂ§ñÂ•ó„ÄÅÂõ¥Â∑æ\n';
        } else {
          clothing += 'üß§ ÁæΩÁªíÊúç„ÄÅÊâãÂ•ó„ÄÅÂ∏ΩÂ≠ê\n';
        }
        
        if (condition.includes('Èõ®')) {
          clothing += 'üåÇ Êê∫Â∏¶Èõ®ÂÖ∑\n';
        }
        
        if (windSpeed > 20) {
          clothing += 'üí® È£éÂ§ßÔºåÊ≥®ÊÑèÈò≤È£é\n';
        }
        
        return clothing;
      } catch (error) {
        return error.message;
      }
    }

    // ÂéÜÂè≤Êï∞ÊçÆÂäüËÉΩ
    async getHistoricalWeather(args) {
      try {
        const days = Math.min(Math.max(0, args.DAYS), this.weatherHistory.length - 1);
        
        if (days >= this.weatherHistory.length) {
          return 'ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥';
        }
        
        const history = this.weatherHistory[days];
        const current = history.data.current_condition[0];
        
        const date = new Date(history.timestamp);
        const dateStr = date.toLocaleDateString('zh-CN');
        
        return `${args.LOCATION} ${days}Â§©Ââç (${dateStr}): ${current.weatherDesc[0].value} ${current.temp_C}‚ÑÉ`;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÂéÜÂè≤Â§©Ê∞î';
      }
    }

    async getWeatherStatistics(args) {
      try {
        if (this.weatherHistory.length < 2) {
          return 'ÂéÜÂè≤Êï∞ÊçÆ‰∏çË∂≥ÔºåÊó†Ê≥ïÁîüÊàêÁªüËÆ°';
        }
        
        const recentHistory = this.weatherHistory.slice(0, 5); // ÊúÄËøë5Ê¨°ËÆ∞ÂΩï
        let totalTemp = 0;
        let maxTemp = -Infinity;
        let minTemp = Infinity;
        
        for (const record of recentHistory) {
          const temp = parseInt(record.data.current_condition[0].temp_C);
          totalTemp += temp;
          maxTemp = Math.max(maxTemp, temp);
          minTemp = Math.min(minTemp, temp);
        }
        
        const avgTemp = (totalTemp / recentHistory.length).toFixed(1);
        
        return `${args.LOCATION} ËøëÊúüÁªüËÆ°:
Âπ≥ÂùáÊ∏©Â∫¶: ${avgTemp}‚ÑÉ
ÊúÄÈ´òÊ∏©Â∫¶: ${maxTemp}‚ÑÉ
ÊúÄ‰ΩéÊ∏©Â∫¶: ${minTemp}‚ÑÉ
Êï∞ÊçÆÊ†∑Êú¨: ${recentHistory.length}Ê¨°`;
      } catch (error) {
        return 'Êó†Ê≥ïÁîüÊàêÂ§©Ê∞îÁªüËÆ°';
      }
    }

    async getExtremeWeather(args) {
      try {
        // Ê®°ÊãüÊûÅÁ´ØÂ§©Ê∞îËÆ∞ÂΩï
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const temp = parseInt(current.temp_C);
        
        let extremes = `${args.LOCATION} ÂΩìÂâçÊûÅÁ´ØÂ§©Ê∞îÁä∂ÂÜµ:\n`;
        
        if (temp >= 35) {
          extremes += 'üî• ÊûÅÁ´ØÈ´òÊ∏©Ë≠¶Âëä\n';
        }
        if (temp <= -15) {
          extremes += '‚ùÑÔ∏è ÊûÅÁ´Ø‰ΩéÊ∏©Ë≠¶Âëä\n';
        }
        if (parseInt(current.windspeedKmph) >= 60) {
          extremes += 'üí® ÊûÅÁ´ØÂ§ßÈ£éË≠¶Âëä\n';
        }
        if (parseFloat(current.precipMM) >= 100) {
          extremes += 'üåßÔ∏è ÊûÅÁ´ØÊö¥Èõ®Ë≠¶Âëä\n';
        }
        
        if (extremes === `${args.LOCATION} ÂΩìÂâçÊûÅÁ´ØÂ§©Ê∞îÁä∂ÂÜµ:\n`) {
          extremes += '‚úÖ Êó†ÊûÅÁ´ØÂ§©Ê∞îÁä∂ÂÜµ';
        }
        
        return extremes;
      } catch (error) {
        return 'Êó†Ê≥ïËé∑ÂèñÊûÅÁ´ØÂ§©Ê∞î‰ø°ÊÅØ';
      }
    }

    // Á≥ªÁªüÂäüËÉΩ
    setUserPreference(args) {
      switch (args.PREFERENCE) {
        case 'Ê∏©Â∫¶Âçï‰Ωç':
          this.userPreferences.defaultUnit = args.VALUE;
          break;
        case 'È£éÈÄüÂçï‰Ωç':
          this.userPreferences.defaultWindUnit = args.VALUE;
          break;
        case 'ËØ≠Ë®Ä':
          this.userPreferences.language = args.VALUE === 'Ëã±Êñá' ? 'Ëã±Êñá' : '‰∏≠Êñá';
          break;
      }
    }

    getSystemStatus() {
      const status = `üå§Ô∏è Â§©Ê∞îÁ≥ªÁªüÁä∂ÊÄÅ:
üìä ÁºìÂ≠òÊï∞ÊçÆ: ${this.currentWeatherData ? 'Êúâ' : 'Êó†'}
üïê ÊúÄÂêéÊõ¥Êñ∞: ${this.getLastUpdateTime()}
‚≠ê Êî∂ËóèÂú∞ÁÇπ: ${this.favoriteLocations.length}‰∏™
üìà ÂéÜÂè≤ËÆ∞ÂΩï: ${this.weatherHistory.length}Êù°
‚öôÔ∏è Ê∏©Â∫¶Âçï‰Ωç: ${this.userPreferences.defaultUnit}
üåê ËØ≠Ë®Ä: ${this.userPreferences.language}`;
      
      return status;
    }

    // Â∑•ÂÖ∑ÊñπÊ≥ï
    async getWeatherEmoji(args) {
      try {
        const weatherData = await this.fetchWeatherData(args.LOCATION);
        const current = weatherData.data.current_condition[0];
        const weatherCode = parseInt(current.weatherCode);
        
        const emojiMap = {
          113: '‚òÄÔ∏è', 116: '‚õÖ', 119: '‚òÅÔ∏è', 122: '‚òÅÔ∏è',
          143: 'üå´Ô∏è', 176: 'üå¶Ô∏è', 179: 'üåßÔ∏è', 182: 'üåßÔ∏è',
          200: '‚õàÔ∏è', 227: '‚ùÑÔ∏è', 230: '‚ùÑÔ∏è', 248: 'üå´Ô∏è',
          260: 'üå´Ô∏è', 263: 'üå¶Ô∏è', 266: 'üåßÔ∏è', 281: 'üåßÔ∏è',
          284: 'üåßÔ∏è', 293: 'üå¶Ô∏è', 296: 'üåßÔ∏è', 299: 'üåßÔ∏è',
          302: 'üåßÔ∏è', 305: 'üåßÔ∏è', 308: 'üåßÔ∏è', 311: 'üåßÔ∏è',
          314: 'üåßÔ∏è', 317: 'üåßÔ∏è', 320: 'üåßÔ∏è', 323: '‚ùÑÔ∏è',
          326: '‚ùÑÔ∏è', 329: '‚ùÑÔ∏è', 332: '‚ùÑÔ∏è', 335: '‚ùÑÔ∏è',
          338: '‚ùÑÔ∏è', 350: 'üåßÔ∏è', 353: 'üå¶Ô∏è', 356: 'üåßÔ∏è',
          359: 'üåßÔ∏è', 362: 'üåßÔ∏è', 365: 'üåßÔ∏è', 368: '‚ùÑÔ∏è',
          371: '‚ùÑÔ∏è', 374: 'üåßÔ∏è', 377: 'üåßÔ∏è', 386: '‚õàÔ∏è',
          389: '‚õàÔ∏è', 392: '‚õàÔ∏è', 395: '‚ùÑÔ∏è'
        };
        
        return emojiMap[weatherCode] || 'üåà';
      } catch (error) {
        return '‚ùì';
      }
    }

    getLastUpdateTime() {
      if (!this.lastFetchTime) return '‰ªéÊú™Êõ¥Êñ∞';
      
      const now = Date.now();
      const diff = Math.floor((now - this.lastFetchTime) / 1000);
      
      if (diff < 60) return `${diff}ÁßíÂâç`;
      if (diff < 3600) return `${Math.floor(diff / 60)}ÂàÜÈíüÂâç`;
      return `${Math.floor(diff / 3600)}Â∞èÊó∂Ââç`;
    }
  }

  Scratch.extensions.register(new WeatherExtension());
})(Scratch);
