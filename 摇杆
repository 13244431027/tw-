/* 修正定位版 TurboWarp 摇杆扩展 */
(function (Scratch) {
  'use strict';
  if (!Scratch.extensions.unsandboxed)
    throw new Error('需 unsandboxed 环境');

  /* ---------- 1. 创建摇杆容器，初始隐藏 ---------- */
  const id = 'tw-joystick-root';
  let root = document.getElementById(id);
  if (!root) {
    root = document.createElement('div');
    root.id = id;
    Object.assign(root.style, {
      position: 'absolute',   /* 关键：absolute 相对舞台容器 */
      left: 0,
      bottom: 0,
      zIndex: 9999,
      pointerEvents: 'none',
      width: '160px',
      height: '160px',
      display: 'none'
    });
    document.getElementById('app').appendChild(root); // 塞进舞台
  }

  /* ---------- 2. 画布 ---------- */
  const cv = document.createElement('canvas');
  cv.width = cv.height = 160;
  Object.assign(cv.style, {
    pointerEvents: 'auto',
    touchAction: 'none',
    width: '100%',
    height: '100%'
  });
  root.appendChild(cv);
  const ctx = cv.getContext('2d');

  /* ---------- 3. 摇杆状态 ---------- */
  let knobX = 0, knobY = 0, dist = 0, angle = 0, pressed = false;
  const maxPixels = 50, center = 80;
  let activeId = null;

  /* ---------- 4. 触摸逻辑（同上，略） ---------- */
  function updateKnob(cx, cy) {
    const r = cv.getBoundingClientRect();
    const x = cx - r.left - center;
    const y = cy - r.top - center;
    const len = Math.hypot(x, y);
    if (len &lt;= maxPixels) { knobX = x / maxPixels; knobY = -y / maxPixels; }
    else { knobX = x / len; knobY = -y / len; }
    dist = Math.min(len / maxPixels, 1);
    angle = (Math.atan2(-knobY, knobX) * 180 / Math.PI + 360) % 360;
    pressed = true;
  }
  function resetKnob() { knobX = knobY = dist = 0; angle = 0; pressed = false; }

  cv.addEventListener('touchstart', e =&gt; {
    e.preventDefault();
    if (activeId === null) {
      activeId = e.changedTouches[0].identifier;
      updateKnob(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
  });
  cv.addEventListener('touchmove', e =&gt; {
    e.preventDefault();
    for (const t of e.changedTouches)
      if (t.identifier === activeId) { updateKnob(t.clientX, t.clientY); break; }
  });
  cv.addEventListener('touchend', e =&gt; {
    e.preventDefault();
    for (const t of e.changedTouches)
      if (t.identifier === activeId) { activeId = null; resetKnob(); break; }
  });

  /* ---------- 5. 绘制 ---------- */
  function draw() {
    ctx.clearRect(0, 0, 160, 160);
    ctx.beginPath();
    ctx.arc(center, center, maxPixels + 20, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fill();
    const kx = center + knobX * maxPixels;
    const ky = center - knobY * maxPixels;
    ctx.beginPath();
    ctx.arc(kx, ky, 25, 0, Math.PI * 2);
    ctx.fillStyle = pressed ? '#ff6b6b' : '#fff';
    ctx.fill();
    ctx.strokeStyle = '#00000033';
    ctx.lineWidth = 2;
    ctx.stroke();
    requestAnimationFrame(draw);
  }
  draw();

  /* ---------- 6. 显示/隐藏 ---------- */
  const show = () =&gt; (root.style.display = 'block');
  const hide = () =&gt; { root.style.display = 'none'; resetKnob(); };

  /* ---------- 7. 积木 ---------- */
  const info = {
    id: 'mobileJoystick',
    name: '摇杆',
    blocks: [
      { opcode: 'getX',     blockType: Scratch.BlockType.REPORTER, text: '摇杆 X' },
      { opcode: 'getY',     blockType: Scratch.BlockType.REPORTER, text: '摇杆 Y' },
      { opcode: 'getDistance', blockType: Scratch.BlockType.REPORTER, text: '摇杆距离' },
      { opcode: 'getAngle', blockType: Scratch.BlockType.REPORTER, text: '摇杆角度' },
      { opcode: 'isPressed', blockType: Scratch.BlockType.BOOLEAN, text: '摇杆按下？' },
      { opcode: 'show', blockType: Scratch.BlockType.COMMAND, text: '显示摇杆' },
      { opcode: 'hide', blockType: Scratch.BlockType.COMMAND, text: '隐藏摇杆' }
    ]
  };

  class Extension {
    getInfo() { return info; }
    getX()      { return knobX; }
    getY()      { return knobY; }
    getDistance() { return dist; }
    getAngle()  { return angle; }
    isPressed() { return pressed; }
    show() { show(); }
    hide() { hide(); }
  }

  Scratch.extensions.register(new Extension());
})(Scratch);
